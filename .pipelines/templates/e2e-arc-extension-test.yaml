jobs:
  - job: e2e_arc_test
    variables:
    - name: AZURE_ENVIRONMENT_FILEPATH
      value: /etc/kubernetes/custom_environment.json
    - name: VOLUME_NAME
      value: cloudenvfile-vol
    - group: csi-secrets-store-e2e
    - name: CLUSTER_CONFIG
      value: linux
    - name: CLUSTER_TYPE
      value: arc
    - name: OS_TYPE
      value: e2e
    steps:
      - template: build-images.yaml
      - template: install-oras.yaml
      - template: install-helm3.yaml
      - script: |
          buildNumber="$(echo $(Build.BuildNumber) | tr -d '.')"
          version="0.0.$buildNumber"
          echo "##vso[task.setvariable variable=EXT_VERSION]$version"

          helm dependency update manifest_staging/charts/csi-secrets-store-provider-azure
          helm package manifest_staging/charts/csi-secrets-store-provider-azure --version $version

          echo "Authenticating..."
          az acr login -n $(STAGING_REGISTRY_NAME)

          echo 'Pushing chart...'
          oras push $(STAGING_REGISTRY):$version ./csi-secrets-store-provider-azure-$version.tgz:application/tar+gzip --debug
        displayName: 'Push OCI helm chart to ACR'
        condition: succeeded()
      - script: |
          az extension add --name connectedk8s
          az extension add --name k8s-extension
        displayName: "add cli extensions"
        condition: succeeded()
      - script: |
          make install-helm install-kubectl setup-kind
        displayName: "install dependencies and setup kind"
        condition: succeeded()
      - script: |
          clusterName=sscd-arc-e2e-$(openssl rand -hex 6)
          echo "##vso[task.setvariable variable=AZURE_CLUSTER_NAME]$clusterName"
          echo "cluster name is set to - $clusterName"
        displayName: "set cluster name"
        condition: succeeded()
      - script: |
          az group create -n ${AZURE_CLUSTER_NAME} -l $(AZURE_CANARY_LOCATION)

          az connectedk8s connect -n ${AZURE_CLUSTER_NAME} -g ${AZURE_CLUSTER_NAME} --no-wait

          # It takes time for Arc pods to come up. Sometimes, in such cases helm might report unable to install helm release, but in fact Arc operators gets installed and able to connect to the cluster. Also, az connectedk8s connect will go through different phases (Connecting, Connected etc.) of installation. So to address both, we are checking the status later without waiting.
          echo "verifying cluster connectivity..."
          for i in $(seq 1 25); do
            provisioningState=$(az connectedk8s list --resource-group ${AZURE_CLUSTER_NAME} --query "[*].provisioningState" -otsv)
            connectivityStatus=$(az connectedk8s list --resource-group ${AZURE_CLUSTER_NAME} --query "[*].connectivityStatus" -otsv)
            if [ "$provisioningState" == "Succeeded" ]  && [ "$connectivityStatus" == "Connected" ]; then
              echo "KinD cluster is 'Connected'"
              break
            else
              echo "Provisioning state - $provisioningState.  Connectivity status - $connectivityStatus"
              sleep 1
            fi
          done

          if [ "$connectivityStatus" != "Connected" ]; then
            echo "failed to connect to the cluster."
            exit 1
          fi
        displayName: "connect KinD cluster"
        condition: succeeded()
      - script: |
          az k8s-extension create \
          --name ${AZURE_CLUSTER_NAME} \
          --extension-type Microsoft.AzureKeyVaultSecretsProvider \
          --scope cluster --cluster-name ${AZURE_CLUSTER_NAME} \
          --resource-group ${AZURE_CLUSTER_NAME} \
          --cluster-type connectedClusters --release-train dev \
          --version $(EXT_VERSION) \
          --release-namespace kube-system \
          --configuration-settings 'secrets-store-csi-driver.enableSecretRotation=true' 'secrets-store-csi-driver.rotationPollInterval=30s' 'linux.image.tag=$(IMAGE_VERSION)' 'linux.image.repository=$(CI_REGISTRY)/$(CI_IMAGE_NAME)' 'secrets-store-csi-driver.syncSecret.enabled=true' 'linux.volumes[0].name=$(VOLUME_NAME)' 'linux.volumes[0].hostPath.path=$(AZURE_ENVIRONMENT_FILEPATH)' 'linux.volumes[0].hostPath.type=File' 'linux.volumeMounts[0].name=$(VOLUME_NAME)' 'linux.volumeMounts[0].mountPath=$(AZURE_ENVIRONMENT_FILEPATH)'

          # Arc extensions will go through different phases (Pending, Installed etc.) of installation. We want to make sure extension is 'Installed' before running e2e tests.
          echo "verifying extension install status..."
          for i in $(seq 1 25); do
            installState=$(az k8s-extension show -c ${AZURE_CLUSTER_NAME} -t connectedClusters -n ${AZURE_CLUSTER_NAME} -g ${AZURE_CLUSTER_NAME} --query "installState" -otsv)
            if [ "$installState" == "Installed" ]; then
              echo "AzureKeyVaultSecretsProvider extension is 'Installed'"
              break
            else
              echo "Install state - $installState"
              sleep 1
            fi
          done

          if [ "$installState" != "Installed" ]; then
            echo "failed to install extension."
            exit 1
          fi

          helm ls -A
          helm get values ${AZURE_CLUSTER_NAME} -n kube-system
        displayName: "install AzureKeyVaultSecretsProvider extension"
        condition: succeeded()
      - script: |
          make e2e-test
        displayName: Run e2e tests
        env:
          AZURE_CLIENT_ID: $(AZURE_CLIENT_ID)
          AZURE_CLIENT_SECRET: $(AZURE_CLIENT_SECRET)
          KEY_NAME: $(KEY_NAME)
          KEY_VERSION: $(KEY_VERSION)
          KEYVAULT_NAME: $(KEYVAULT_NAME)
          SECRET_NAME: $(SECRET_NAME)
          TENANT_ID: $(TENANT_ID)
          CI_KIND_CLUSTER: true
          AZURE_ENVIRONMENT_FILEPATH: $(AZURE_ENVIRONMENT_FILEPATH)
          # setting IS_SOAK_TEST env var since arc extension manages installation of chart.
        IS_SOAK_TEST: true
      - script: |
          az acr repository delete --name $(STAGING_REGISTRY_NAME) --image $(STAGING_REGISTRY):${EXT_VERSION} -y || true
        displayName: "delete e2e OCI helm chart"
        condition: always()
      - template: teardown.yaml
      - template: cleanup-images.yaml