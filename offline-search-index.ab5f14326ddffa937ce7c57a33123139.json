

























[{"body":"Construct PEM Chain Feature Flag  Available in AKV Provider release 0.0.12+\n The Azure Key Vault provider for Secrets Store CSI Driver by default fetches the chain of certificates from Keyvault and writes to the mount in the same order in which the certificate chain was uploaded. This is an experimental feature that supports reordering of the certificate chain in the following order:\nSERVER INTERMEDIATE ROOT KEY To enable this feature, set --construct-pem-chain=true in the provider deployment YAMLs. If using helm to install the driver and provider, set constructPEMChain: true.\nRefer to #156 for more details.\n","categories":"","description":"Optional configuration feature flags\n","excerpt":"Optional configuration feature flags\n","ref":"/secrets-store-csi-driver-provider-azure/configurations/feature-flags/","tags":"","title":"Feature Flags"},{"body":"","categories":"","description":"This guide will walk you through the steps to configure and run the Azure Key Vault provider for Secrets Store CSI driver on Kubernetes.\n","excerpt":"This guide will walk you through the steps to configure and run the ‚Ä¶","ref":"/secrets-store-csi-driver-provider-azure/getting-started/","tags":"","title":"Getting Started"},{"body":"   ","categories":"","description":"This demo created by [Houssem Dellai](https://twitter.com/HoussemDellai) is using AAD Pod Identity and Secret Store CSI provider for Key Vault to retrieve database login and password from Azure Key Vault.\n","excerpt":"This demo created by [Houssem ‚Ä¶","ref":"/secrets-store-csi-driver-provider-azure/demos/community-demos-and-presentations/houssem-dellai/","tags":"","title":"Houssem Dellai - Retrieving database login info from Azure KeyVault"},{"body":"","categories":"","description":"The Azure Key Vault Provider offers four modes for accessing a Key Vault instance\n","excerpt":"The Azure Key Vault Provider offers four modes for accessing a Key ‚Ä¶","ref":"/secrets-store-csi-driver-provider-azure/configurations/identity-access-modes/","tags":"","title":"Identity Access Modes"},{"body":"Install the Secrets Store CSI Driver and the Azure Keyvault Provider Prerequisites Recommended Kubernetes version:\n For Linux - v1.16.0+ For Windows - v1.18.0+   For Kubernetes version 1.15 and below, please use Azure Keyvault Flexvolume\n Deployment using Helm Azure Key Vault Provider for Secrets Store CSI Driver allows users to customize their installation via Helm.\n Recommended to use Helm3\n helm repo add csi-secrets-store-provider-azure https://raw.githubusercontent.com/Azure/secrets-store-csi-driver-provider-azure/master/charts helm install csi csi-secrets-store-provider-azure/csi-secrets-store-provider-azure The helm charts hosted in Azure/secrets-store-csi-driver-provider-azure repo include the Secrets Store CSI Driver helm charts as a dependency. Running the above helm install command will install both the Secrets Store CSI Driver and Azure Key Vault provider.\nValues For a list of customizable values that can be injected when invoking helm install, please see the Helm chart configurations.\nUsing Deployment yamls   Install the Secrets Store CSI Driver\nüí° Follow the Installation guide for the Secrets Store CSI Driver to install the driver.\n Result csidriver.storage.k8s.io/secrets-store.csi.k8s.io created serviceaccount/secrets-store-csi-driver created clusterrole.rbac.authorization.k8s.io/secretproviderclasses-role created clusterrolebinding.rbac.authorization.k8s.io/secretproviderclasses-rolebinding created clusterrole.rbac.authorization.k8s.io/secretprovidersyncing-role created clusterrolebinding.rbac.authorization.k8s.io/secretprovidersyncing-rolebinding created daemonset.apps/csi-secrets-store-windows created daemonset.apps/csi-secrets-store created customresourcedefinition.apiextensions.k8s.io/secretproviderclasses.secrets-store.csi.x-k8s.io created customresourcedefinition.apiextensions.k8s.io/secretproviderclasspodstatuses.secrets-store.csi.x-k8s.io created   To validate the driver is running as expected, run the following command:\nkubectl get pods -l app=csi-secrets-store -n kube-system You should see the driver pods running on each agent node:\nNAME READY STATUS RESTARTS AGE csi-secrets-store-bp4f4 3/3 Running 0 24s To validate the --grpc-supported-providers=azure arg has been configured correctly, run the following command:\nkubectl get ds -l app=csi-secrets-store -o jsonpath='{range .items[*]}{.spec.template.spec.containers[1].args}{\"\\n\"}' You should see the args for the secrets-store container in the driver pods for each node:\n[\"--debug=true\",\"--endpoint=$(CSI_ENDPOINT)\",\"--nodeid=$(KUBE_NODE_NAME)\",\"--provider-volume=/etc/kubernetes/secrets-store-csi-providers\",\"--grpc-supported-providers=azure\",\"--metrics-addr=:8080\"]   Install the Azure Key Vault provider\nFor linux nodes\nkubectl apply -f https://raw.githubusercontent.com/Azure/secrets-store-csi-driver-provider-azure/master/deployment/provider-azure-installer.yaml For windows nodes\nkubectl apply -f https://raw.githubusercontent.com/Azure/secrets-store-csi-driver-provider-azure/master/deployment/provider-azure-installer-windows.yaml NOTE: Installing the provider using the deployment yamls from master will always install the latest version. If you want to deploy a specific version of the provider use the tagged release yamls.\nTo validate the provider‚Äôs installer is running as expected, run the following commands:\nkubectl get pods -l app=csi-secrets-store-provider-azure You should see the provider pods running on each agent node:\nNAME READY STATUS RESTARTS AGE csi-secrets-store-provider-azure-4ngf4 1/1 Running 0 8s csi-secrets-store-provider-azure-bxr5k 1/1 Running 0 8s   In addition, if you are using Secrets Store CSI Driver and the Azure Keyvault Provider in a cluster with pod security policy enabled, review and create the following policy that enables the spec required for Secrets Store CSI Driver and the Azure Keyvault Provider to work:\nkubectl apply -f https://raw.githubusercontent.com/Azure/secrets-store-csi-driver-provider-azure/master/deployment/pod-security-policy.yaml Uninstallation Using Helm If you deployed the Secrets Store CSI Driver and Azure Key Vault provider using the helm charts from Azure/secrets-store-csi-driver-provider-azure, then run the following command to uninstall:\nhelm delete \u003crelease name\u003e Using deployment yamls If the driver and provider were installed using deployment yamls, then you can delete all the components with the following commands:\n# To delete AKV provider pods from Linux nodes kubectl delete -f https://raw.githubusercontent.com/Azure/secrets-store-csi-driver-provider-azure/master/deployment/provider-azure-installer.yaml # To delete AKV provider pods from Windows nodes kubectl delete -f https://raw.githubusercontent.com/Azure/secrets-store-csi-driver-provider-azure/master/deployment/provider-azure-installer-windows.yaml Delete the Secrets Store CSI Driver by running kubectl delete with all the manifests in here. If the Secrets Store CSI Driver was installed using the helm charts hosted in kubernetes-sigs/secrets-store-csi-driver, then run the following command to delete the driver components:\nhelm delete \u003crelease name\u003e ","categories":"","description":"How to install Secrets Store CSI Driver and Azure Key Vault Provider on your clusters.\n","excerpt":"How to install Secrets Store CSI Driver and Azure Key Vault Provider ‚Ä¶","ref":"/secrets-store-csi-driver-provider-azure/getting-started/installation/","tags":"","title":"Installation"},{"body":"These secrets are synced with Kubernetes Secret object and then injected into deployment as ENV variables.\n  ","categories":"","description":"This demo created by [Nilesh Gule](https://twitter.com/NileshGule) is using VMSS Managed Identity and Secret Store CSI provider for Key Vault to retrieve RabbitMQ related secret from Azure Key Vault.\n","excerpt":"This demo created by [Nilesh Gule](https://twitter.com/NileshGule) is ‚Ä¶","ref":"/secrets-store-csi-driver-provider-azure/demos/community-demos-and-presentations/nilesh-gule/","tags":"","title":"Nilesh Gule - Retrieving RabbitMQ related secret from Azure KeyVault"},{"body":" Supported with Linux and Windows\n \rExamples\r SecretProviderClass  # This is a SecretProviderClass example using a service principal to access Key VaultapiVersion:secrets-store.csi.x-k8s.io/v1alpha1kind:SecretProviderClassmetadata:name:azure-kvnamespec:provider:azureparameters:usePodIdentity:\"false\"# [OPTIONAL] if not provided, will default to \"false\"keyvaultName:\"kvname\"# the name of the KeyVaultcloudName:\"\"# [OPTIONAL for Azure] if not provided, azure environment will default to AzurePublicCloud objects:| array: - | objectName: secret1 objectType: secret # object types: secret, key or cert objectVersion: \"\" # [OPTIONAL] object versions, default to latest if empty - | objectName: key1 objectType: key objectVersion: \"\" tenantId: \"tid\" # the tenant ID of the KeyVault  Pod yaml  # This is a sample pod definition for using SecretProviderClass and service-principal to access Key Vaultkind:PodapiVersion:v1metadata:name:busybox-secrets-store-inlinespec:containers:- name:busyboximage:k8s.gcr.io/e2e-test-images/busybox:1.29command:- \"/bin/sleep\"- \"10000\"volumeMounts:- name:secrets-store-inlinemountPath:\"/mnt/secrets-store\"readOnly:truevolumes:- name:secrets-store-inlinecsi:driver:secrets-store.csi.k8s.ioreadOnly:truevolumeAttributes:secretProviderClass:\"azure-kvname\"nodePublishSecretRef:# Only required when using service principal modename:secrets-store-creds # Only required when using service principal mode\rConfigure Service Principal to access Keyvault   Add your service principal credentials as a Kubernetes secrets accessible by the Secrets Store CSI driver. If using AKS you can learn about service principals in AKS here.\nA properly configured service principal will need to be passed in with the Service Principal‚Äôs appId and password. Ensure this service principal has all the required permissions to access content in your Azure Key Vault instance.\n# Client ID (AZURE_CLIENT_ID) will be the App ID of your service principal # Client Secret (AZURE_CLIENT_SECRET) will be the Password of your service principal kubectl create secret generic secrets-store-creds --from-literal clientid=\u003cAZURE_CLIENT_ID\u003e --from-literal clientsecret=\u003cAZURE_CLIENT_SECRET\u003e  NOTE The Kubernetes Secret containing the credentials need to be created in the same namespace as the application pod. If pods in multiple namespaces need to use the same SP to access Keyvault, this Kubernetes Secret needs to be created in each namespace.\r  If you do not have a service principal, run the following Azure CLI command to create a new service principal.\n# OPTIONAL: Create a new service principal, be sure to notate the SP secret returned on creation. az ad sp create-for-rbac --skip-assignment --name $SPNAME # If you lose your AZURE_CLIENT_SECRET (SP Secret), you can reset and receive it with this command: # az ad sp credential reset --name $SPNAME --credential-description \"APClientSecret\" --query password -o tsv With an existing service principal, assign the following permissions:\n# Set environment variables SPNAME=\u003cservicePrincipalName\u003e AZURE_CLIENT_ID=$(az ad sp show --id http://${SPNAME} --query appId -o tsv) KEYVAULT_NAME=\u003ckey-vault-name\u003e KEYVAULT_RESOURCE_GROUP=\u003cresource-group-name-for-KV\u003e SUBID=\u003csubscription-id\u003e az keyvault set-policy -n $KEYVAULT_NAME --key-permissions get --spn $AZURE_CLIENT_ID az keyvault set-policy -n $KEYVAULT_NAME --secret-permissions get --spn $AZURE_CLIENT_ID az keyvault set-policy -n $KEYVAULT_NAME --certificate-permissions get --spn $AZURE_CLIENT_ID   Update your deployment yaml to reference the service principal kubernetes secret created in the previous step\nIf you did not change the name of the secret reference previously, no changes are needed.\nnodePublishSecretRef:name:secrets-store-creds  ","categories":"","description":"Use a Service Principal to access Keyvault.\n","excerpt":"Use a Service Principal to access Keyvault.\n","ref":"/secrets-store-csi-driver-provider-azure/configurations/identity-access-modes/service-principal-mode/","tags":"","title":"Service Principal"},{"body":"Run the following commands to set Azure-related environment variables and login to Azure via az login:\nexport SUBSCRIPTION_ID=\"\u003cSubscriptionID\u003e\" export TENANT_ID=\"\u003ctenant id\u003e\" # login as a user and set the appropriate subscription ID az login az account set -s \"${SUBSCRIPTION_ID}\" export KEYVAULT_RESOURCE_GROUP=\u003ckeyvault-resource-group\u003e export KEYVAULT_LOCATION=\u003ckeyvault-location\u003e export KEYVAULT_NAME=secret-store-$(cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w 10 | head -n 1) 1. Deploy Azure Key Vault Provider for Secrets Store CSI Driver Deploy the Azure Key Vault Provider and Secrets Store CSI Driver components:\nhelm repo add csi-secrets-store-provider-azure https://raw.githubusercontent.com/Azure/secrets-store-csi-driver-provider-azure/master/charts helm install csi csi-secrets-store-provider-azure/csi-secrets-store-provider-azure Refer to installation for more details and validation.\n2. Create Keyvault and set secrets Create an Azure Keyvault instance:\naz group create -n ${KEYVAULT_RESOURCE_GROUP} --location ${KEYVAULT_LOCATION} az keyvault create -n ${KEYVAULT_NAME} -g ${KEYVAULT_RESOURCE_GROUP} --location ${KEYVAULT_LOCATION} Add a secret to your Keyvault:\naz keyvault secret set --vault-name ${KEYVAULT_NAME} --name secret1 --value \"Hello!\" 3. Create an identity on Azure and set access policies Refer to Identity Access Modes to see the list of supported modes for accessing the Key Vault instance.\nIn this walkthrough, we will be using the Service Principal auth mode for accessing the Key Vault instance we just created.\n# Create a service principal to access keyvault export SERVICE_PRINCIPAL_CLIENT_SECRET=\"$(az ad sp create-for-rbac --skip-assignment --name http://secrets-store-test --query 'password' -otsv)\" export SERVICE_PRINCIPAL_CLIENT_ID=\"$(az ad sp show --id http://secrets-store-test --query 'appId' -otsv)\" Set the access policy for keyvault objects:\naz keyvault set-policy -n ${KEYVAULT_NAME} --secret-permissions get --spn ${SERVICE_PRINCIPAL_CLIENT_ID} 4. Create the Kubernetes Secret with credentials Create the Kubernetes secret with the service principal credentials:\nkubectl create secret generic secrets-store-creds --from-literal clientid=${SERVICE_PRINCIPAL_CLIENT_ID} --from-literal clientsecret=${SERVICE_PRINCIPAL_CLIENT_SECRET}  NOTE: This step is required only if you‚Äôre using service principal to provide access to Keyvault.\n 5. Deploy SecretProviderClass Refer to section on the required and configurable parameters in SecretProviderClass object.\nCreate SecretProviderClass in your cluster that contains all the required parameters:\ncat \u003c\u003cEOF | kubectl apply -f -apiVersion:secrets-store.csi.x-k8s.io/v1alpha1kind:SecretProviderClassmetadata:name:azure-kvnamenamespace:defaultspec:provider:azureparameters:usePodIdentity:\"false\"useVMManagedIdentity:\"false\"userAssignedIdentityID:\"\"keyvaultName:\"${KEYVAULT_NAME}\"objects:| array: - | objectName: secret1 objectType: secret objectVersion: \"\" tenantId: \"${TENANT_ID}\"EOF6. Deployment and Validation Create the pod with volume referencing the secrets-store.csi.k8s.io driver:\ncat \u003c\u003cEOF | kubectl apply -f -kind:PodapiVersion:v1metadata:name:busybox-secrets-store-inlinespec:containers:- name:busyboximage:k8s.gcr.io/e2e-test-images/busybox:1.29command:- \"/bin/sleep\"- \"10000\"volumeMounts:- name:secrets-store-inlinemountPath:\"/mnt/secrets-store\"readOnly:truevolumes:- name:secrets-store-inlinecsi:driver:secrets-store.csi.k8s.ioreadOnly:truevolumeAttributes:secretProviderClass:\"azure-kvname\"nodePublishSecretRef:# Only required when using service principal modename:secrets-store-creds # Only required when using service principal modeEOFTo validate, once the pod is started, you should see the new mounted content at the volume path specified in your deployment yaml.\n## show secrets held in secrets-store kubectl exec busybox-secrets-store-inline -- ls /mnt/secrets-store/ ## print a test secret held in secrets-store kubectl exec busybox-secrets-store-inline -- cat /mnt/secrets-store/secret1 If successful, the output will be similar to:\nkubectl exec busybox-secrets-store-inline -- ls /mnt/secrets-store/ secret1 kubectl exec busybox-secrets-store-inline -- cat /mnt/secrets-store/secret1 Hello! ","categories":"","description":"You will need Azure CLI installed and a Kubernetes cluster.\n","excerpt":"You will need Azure CLI installed and a Kubernetes cluster.\n","ref":"/secrets-store-csi-driver-provider-azure/demos/standard-walkthrough/","tags":"","title":"Standard Walkthrough"},{"body":"\rExamples\r SecretProviderClass  apiVersion:secrets-store.csi.x-k8s.io/v1alpha1kind:SecretProviderClassmetadata:name:azure-syncspec:provider:azuresecretObjects:# [OPTIONAL] SecretObject defines the desired state of synced K8s secret objects- secretName:foosecrettype:Opaquelabels:environment:\"test\"data:- objectName:secretalias # name of the mounted content to sync. this could be the object name or object alias key:usernameparameters:usePodIdentity:\"true\"keyvaultName:\"$KEYVAULT_NAME\"# the name of the KeyVaultobjects:| array: - | objectName: $SECRET_NAME objectType: secret # object types: secret, key or cert objectAlias: secretalias objectVersion: $SECRET_VERSION # [OPTIONAL] object versions, default to latest if empty - | objectName: $KEY_NAME objectType: key objectVersion: $KEY_VERSION tenantId: \"tid\" # the tenant ID of the KeyVault  Pod yaml  kind:PodapiVersion:v1metadata:name:busybox-secrets-store-inlinespec:containers:- name:busyboximage:k8s.gcr.io/e2e-test-images/busybox:1.29command:- \"/bin/sleep\"- \"10000\"volumeMounts:- name:secrets-store01-inlinemountPath:\"/mnt/secrets-store\"readOnly:truevolumes:- name:secrets-store01-inlinecsi:driver:secrets-store.csi.k8s.ioreadOnly:truevolumeAttributes:secretProviderClass:\"azure-sync\"\rHow to sync mounted content with Kubernetes secret In some cases, you may want to create a Kubernetes Secret to mirror the mounted content. Use the optional secretObjects field to define the desired state of the synced Kubernetes secret objects.\n NOTE: Make sure the objectName in secretObjects matches the file name of the mounted content. This could be the object name or the object alias.\n  The secrets will only sync once you start a pod mounting the secrets. Solely relying on the syncing with Kubernetes secrets feature thus does not work.\n A SecretProviderClass custom resource should have the following components:\napiVersion:secrets-store.csi.x-k8s.io/v1alpha1kind:SecretProviderClassmetadata:name:my-providerspec:provider:azure secretObjects:# [OPTIONAL] SecretObject defines the desired state of synced K8s secret objects- data:- key:username # data field to populateobjectName:foo1 # name of the mounted content to sync. this could be the object name or the object aliassecretName:foosecret # name of the Kubernetes Secret objecttype:Opaque # type of the Kubernetes Secret object e.g. Opaque, kubernetes.io/tls... NOTE: Here is the list of supported Kubernetes Secret types: Opaque, kubernetes.io/basic-auth, bootstrap.kubernetes.io/token, kubernetes.io/dockerconfigjson, kubernetes.io/dockercfg, kubernetes.io/ssh-auth, kubernetes.io/service-account-token, kubernetes.io/tls.\n  Here is a sample SecretProviderClass custom resource that syncs a secret from Azure Key Vault to a Kubernetes secret. To view an example of type kubernetes.io/tls, refer to the ingress-controller-tls sample  ","categories":"","description":"How to sync mounted content with Kubernetes secret\n","excerpt":"How to sync mounted content with Kubernetes secret\n","ref":"/secrets-store-csi-driver-provider-azure/configurations/sync-with-k8-secretes/","tags":"","title":"Sync Mounted Content with Kubernetes Secret"},{"body":"Create a new Azure Key Vault resource or use an existing one In addition to a Kubernetes cluster, you will need an Azure Key Vault resource with secret content to access. Follow this quickstart tutorial to deploy an Azure Key Vault and add an example secret to it.\nReview the settings you desire for your Key Vault, such as what resources (Azure VMs, Azure Resource Manager, etc.) and what kind of network endpoints can access secrets in it.\nTake note of the following properties for use in the next section:\n Name of secret object in Key Vault Secret content type (secret, key, cert) Name of Key Vault resource Azure Tenant ID the Subscription belongs to  Create your own SecretProviderClass Object Create a SecretProviderClass custom resource to provide provider-specific parameters for the Secrets Store CSI driver. In this example, use an existing Azure Key Vault or the Azure Key Vault resource created previously.\n NOTE: The SecretProviderClass has to be in the same namespace as the pod referencing it.\n Update this sample deployment to create a SecretProviderClass resource to provide Azure-specific parameters for the Secrets Store CSI driver.\nTo provide identity to access key vault, refer to the following section.\napiVersion:secrets-store.csi.x-k8s.io/v1alpha1kind:SecretProviderClassmetadata:name:azure-kvnamespec:provider:azureparameters:usePodIdentity:\"false\"# [OPTIONAL] if not provided, will default to \"false\"useVMManagedIdentity:\"false\"# [OPTIONAL available for version \u003e 0.0.4] if not provided, will default to \"false\"userAssignedIdentityID:\"client_id\"# [OPTIONAL available for version \u003e 0.0.4] use the client id to specify which user assigned managed identity to use. If using a user assigned identity as the VM's managed identity, then specify the identity's client id. If empty, then defaults to use the system assigned identity on the VMkeyvaultName:\"kvname\"# the name of the KeyVaultcloudName:\"\"# [OPTIONAL available for version \u003e 0.0.4] if not provided, azure environment will default to AzurePublicCloudcloudEnvFileName:\"\"# [OPTIONAL available for version \u003e 0.0.7] use to define path to file for populating azure environmentobjects:| array: - | objectName: secret1 objectAlias: SECRET_1 # [OPTIONAL available for version \u003e 0.0.4] object alias objectType: secret # object types: secret, key or cert. For Key Vault certificates, refer to https://github.com/Azure/secrets-store-csi-driver-provider-azure/blob/master/docs/getting-certs-and-keys.md for the object type to use objectVersion: \"\" # [OPTIONAL] object versions, default to latest if empty - | objectName: key1 objectAlias: \"\" # If provided then it has to be referenced in [secretObjects].[objectName] to sync with Kubernetes secrets objectType: key objectVersion: \"\" tenantId: \"tid\" # the tenant ID of the KeyVault    Name Required Description Default Value     provider yes specify name of the provider \"\"   usePodIdentity no set to true for using aad-pod-identity to access keyvault ‚Äúfalse‚Äù   useVMManagedIdentity no [available for version \u003e 0.0.4] specify access mode to enable use of User-assigned managed identity ‚Äúfalse‚Äù   userAssignedIdentityID no [available for version \u003e 0.0.4] the user assigned identity ID is required for User-assigned Managed Identity mode \"\"   keyvaultName yes name of a Key Vault instance \"\"   cloudName no [available for version \u003e 0.0.4] name of the azure cloud based on azure go sdk (AzurePublicCloud, AzureUSGovernmentCloud, AzureChinaCloud, AzureGermanCloud, AzureStackCloud) \"\"   cloudEnvFileName no [available for version \u003e 0.0.7] path to the file to be used while populating the Azure Environment (required if target cloud is AzureStackCloud). More details here. \"\"   objects yes a string of arrays of strings \"\"   objectName yes name of a Key Vault object \"\"   objectAlias no [available for version \u003e 0.0.4] specify the filename of the object when written to disk - defaults to objectName if not provided \"\"   objectType yes type of a Key Vault object: secret, key or cert.\nFor Key Vault certificates, refer to doc for the object type to use. \"\"   objectVersion no version of a Key Vault object, if not provided, will use latest \"\"   objectFormat no [available for version \u003e 0.0.7] the format of the Azure Key Vault object, supported types are pem and pfx. objectFormat: pfx is only supported with objectType: secret and PKCS12 or ECC certificates ‚Äúpem‚Äù   objectEncoding no [available for version \u003e 0.0.8] the encoding of the Azure Key Vault secret object, supported types are utf-8, hex and base64. This option is supported only with objectType: secret ‚Äúutf-8‚Äù   tenantId yes tenant ID containing key vault instance \"\"    Provide Identity to Access Key Vault The Azure Key Vault Provider offers four modes for accessing a Key Vault instance:\n Service Principal Pod Identity User-assigned Managed Identity System-assigned Managed Identity  Update your Deployment Yaml To ensure your application is using the Secrets Store CSI driver, update your deployment yaml to use the secrets-store.csi.k8s.io driver and reference the SecretProviderClass resource created in the previous step.\nUpdate your deployment yaml to use the Secrets Store CSI driver and reference the SecretProviderClass resource created in the previous step.\nvolumes:- name:secrets-store-inlinecsi:driver:secrets-store.csi.k8s.ioreadOnly:truevolumeAttributes:secretProviderClass:\"azure-kvname\"Deploy your Kubernetes Resources   Deploy the SecretProviderClass yaml created previously. For example:\nkubectl apply -f https://raw.githubusercontent.com/Azure/secrets-store-csi-driver-provider-azure/master/examples/service-principal/v1alpha1_secretproviderclass_service_principal.yaml\n  Deploy the application yaml created previously. For example:\nkubectl apply -f https://raw.githubusercontent.com/Azure/secrets-store-csi-driver-provider-azure/master/examples/service-principal/pod-inline-volume-service-principal.yaml\n  Validate the secret To validate, once the pod is started, you should see the new mounted content at the volume path specified in your deployment yaml.\n## show secrets held in secrets-store kubectl exec busybox-secrets-store-inline -- ls /mnt/secrets-store/ ## print a test secret held in secrets-store kubectl exec busybox-secrets-store-inline -- cat /mnt/secrets-store/secret1 ","categories":"","description":"This guide will walk you through the steps to configure and run the Azure Key Vault provider for Secrets Store CSI driver on Kubernetes.\n","excerpt":"This guide will walk you through the steps to configure and run the ‚Ä¶","ref":"/secrets-store-csi-driver-provider-azure/getting-started/usage/","tags":"","title":"Using the Azure Key Vault Provider"},{"body":"","categories":"","description":"We have created several demos for you to get familiar with the Azure KeyVault Provider for Secrets Store CSI Driver\n","excerpt":"We have created several demos for you to get familiar with the Azure ‚Ä¶","ref":"/secrets-store-csi-driver-provider-azure/demos/","tags":"","title":"Demos"},{"body":"You can setup the Secrets Store CSI Driver to periodically update the pod volume mount and Kubernetes Secret with the latest content from external secrets-store. Refer to doc for steps on enabling auto rotation.\nNOTE The CSI driver does not restart the application pods. It only handles updating the pod mount and Kubernetes secret similar to how Kubernetes handles updates to Kubernetes secret mounted as volumes.  ","categories":"","description":"Periodically update the pod mount and Kubernetes Secret with the latest content from external secrets store\n","excerpt":"Periodically update the pod mount and Kubernetes Secret with the ‚Ä¶","ref":"/secrets-store-csi-driver-provider-azure/configurations/enable-auto-rotation-secrets/","tags":"","title":"Enable Auto Rotation of Secrets"},{"body":" Supported only on Linux\n \rExamples\r SecretProviderClass  # This is a SecretProviderClass example using aad-pod-identity to access Key VaultapiVersion:secrets-store.csi.x-k8s.io/v1alpha1kind:SecretProviderClassmetadata:name:azure-kvname-podidspec:provider:azureparameters:usePodIdentity:\"true\"# set to true for pod identity access modekeyvaultName:\"kvname\"cloudName:\"\"# [OPTIONAL for Azure] if not provided, azure environment will default to AzurePublicCloudobjects:| array: - | objectName: secret1 objectType: secret # object types: secret, key or cert objectVersion: \"\" # [OPTIONAL] object versions, default to latest if empty - | objectName: key1 objectType: key objectVersion: \"\" tenantId: \"tid\" # the tenant ID of the KeyVault  Pod yaml  # This is a sample pod definition for using SecretProviderClass and aad-pod-identity to access Key Vaultkind:PodapiVersion:v1metadata:name:busybox-secrets-store-inline-podidlabels:aadpodidbinding:\"demo\"# Set the label value to match selector defined in AzureIdentityBindingspec:containers:- name:busyboximage:k8s.gcr.io/e2e-test-images/busybox:1.29command:- \"/bin/sleep\"- \"10000\"volumeMounts:- name:secrets-store01-inlinemountPath:\"/mnt/secrets-store\"readOnly:truevolumes:- name:secrets-store01-inlinecsi:driver:secrets-store.csi.k8s.ioreadOnly:truevolumeAttributes:secretProviderClass:\"azure-kvname-podid\"\rConfigure AAD Pod Identity to access Keyvault Prerequisites\nüí° Make sure you have installed pod identity to your Kubernetes cluster\nThis project makes use of the aad-pod-identity project to handle the identity management of the pods. Reference the aad-pod-identity README if you need further instructions on any of these steps.\nNot all steps need to be followed on the instructions for the aad-pod-identity project as we will also complete some of the steps on our installation here.\n  Install the aad-pod-identity components to your cluster\n  üí° Follow the Role assignment documentation to setup all the required roles for aad-pod-identity components.\n  Install the RBAC enabled aad-pod-identiy infrastructure components:\nkubectl apply -f https://raw.githubusercontent.com/Azure/aad-pod-identity/master/deploy/infra/deployment-rbac.yaml\r    Create an Azure User-assigned Managed Identity\nCreate an Azure User-assigned Managed Identity with the following command. Get clientId and id from the output.\naz identity create -g \u003cresourcegroup\u003e -n \u003cidname\u003e\r  Assign permissions to new identity Ensure your Azure user identity has all the required permissions to read the keyvault instance and to access content within your key vault instance. If not, you can run the following using the Azure CLI:\n# set policy to access keys in your keyvault az keyvault set-policy -n $KEYVAULT_NAME --key-permissions get --spn \u003cYOUR AZURE USER IDENTITY CLIENT ID\u003e # set policy to access secrets in your keyvault az keyvault set-policy -n $KEYVAULT_NAME --secret-permissions get --spn \u003cYOUR AZURE USER IDENTITY CLIENT ID\u003e # set policy to access certs in your keyvault az keyvault set-policy -n $KEYVAULT_NAME --certificate-permissions get --spn \u003cYOUR AZURE USER IDENTITY CLIENT ID\u003e   Add an AzureIdentity for the new identity to your cluster\nEdit and save this as aadpodidentity.yaml\nSet type: 0 for User-Assigned Managed Identity; type: 1 for Service Principal In this case, we are using managed service identity, type: 0. Create a new name for the AzureIdentity. Set resourceID to id of the Azure User Identity created from the previous step.\napiVersion:\"aadpodidentity.k8s.io/v1\"kind:AzureIdentitymetadata:name:\u003cany-name\u003espec:type:0resourceID:/subscriptions/\u003csubid\u003e/resourcegroups/\u003cresourcegroup\u003e/providers/Microsoft.ManagedIdentity/userAssignedIdentities/\u003cidname\u003eclientID:\u003cclientid\u003ekubectl create -f aadpodidentity.yaml   Add AzureIdentityBinding for the AzureIdentity to your cluster\nEdit and save this as aadpodidentitybinding.yaml\napiVersion:\"aadpodidentity.k8s.io/v1\"kind:AzureIdentityBindingmetadata:name:\u003cany-name\u003espec:azureIdentity:\u003cname of the AzureIdentity created in previous step\u003eselector:\u003clabel value to match in your pod\u003ekubectl create -f aadpodidentitybinding.yaml\r  Add the following to this deployment yaml:\nInclude the aadpodidbinding label matching the selector value set in the previous step so that this pod will be assigned an identity\nmetadata:labels:aadpodidbinding:\u003cAzureIdentityBinding Selector created from previous step\u003e  Update this sample deployment to create a SecretProviderClass resource with usePodIdentity: \"true\" to provide Azure-specific parameters for the Secrets Store CSI driver.\nMake sure to set usepodidentity to true\nusepodidentity:\"true\"  Deploy your app\nkubectl apply -f pod.yaml   NOTE When using the Pod Identity option mode, there can be some amount of delay in obtaining the objects from keyvault. During the pod creation time, in this particular mode aad-pod-identity will need to create the AzureAssignedIdentity for the pod based on the AzureIdentity and AzureIdentityBinding, retrieve token for keyvault. This process can take time to complete and it‚Äôs possible for the pod volume mount to fail during this time. When the volume mount fails, kubelet will keep retrying until it succeeds. So the volume mount will eventually succeed after the whole process for retrieving the token is complete.\n","categories":"","description":"Use Pod Identity to access Keyvault.\n","excerpt":"Use Pod Identity to access Keyvault.\n","ref":"/secrets-store-csi-driver-provider-azure/configurations/identity-access-modes/pod-identity-mode/","tags":"","title":"Pod Identity"},{"body":"\rExamples\r SecretProviderClass  apiVersion:secrets-store.csi.x-k8s.io/v1alpha1kind:SecretProviderClassmetadata:name:azure-syncspec:provider:azuresecretObjects:# [OPTIONAL] SecretObject defines the desired state of synced K8s secret objects- secretName:foosecrettype:Opaquelabels:environment:\"test\"data:- objectName:secretalias # name of the mounted content to sync. this could be the object name or object alias key:usernameparameters:usePodIdentity:\"false\"keyvaultName:\"$KEYVAULT_NAME\"# the name of the KeyVaultobjects:| array: - | objectName: $SECRET_NAME objectType: secret # object types: secret, key or cert objectAlias: secretalias objectVersion: $SECRET_VERSION # [OPTIONAL] object versions, default to latest if empty - | objectName: $KEY_NAME objectType: key objectVersion: $KEY_VERSION tenantId: \"tid\" # the tenant ID of the KeyVault  Pod yaml  kind:PodapiVersion:v1metadata:name:busybox-secrets-store-inlinespec:containers:- name:busyboximage:k8s.gcr.io/e2e-test-images/busybox:1.29command:- \"/bin/sleep\"- \"10000\"volumeMounts:- name:secrets-store01-inlinemountPath:\"/mnt/secrets-store\"readOnly:trueenv:- name:SECRET_USERNAMEvalueFrom:secretKeyRef:name:foosecretkey:usernamevolumes:- name:secrets-store01-inlinecsi:driver:secrets-store.csi.k8s.ioreadOnly:truevolumeAttributes:secretProviderClass:\"azure-sync\"\rConfigure your environment variable to reference a Kubernetes Secret Once the secret is created, you may wish to set an ENV VAR in your deployment to reference the new Kubernetes secret.\nspec:containers:- name:busyboximage:k8s.gcr.io/e2e-test-images/busybox:1.29command:- \"/bin/sleep\"- \"10000\"env:- name:SECRET_USERNAMEvalueFrom:secretKeyRef:name:foosecretkey:usernameHere is a sample deployment yaml that creates an ENV VAR from the synced Kubernetes secret.\n","categories":"","description":"Configure your environment variable to reference a Kubernetes Secret\n","excerpt":"Configure your environment variable to reference a Kubernetes Secret\n","ref":"/secrets-store-csi-driver-provider-azure/configurations/set-env-var/","tags":"","title":"Set your Environment Variable to Reference a Kubernetes Secret"},{"body":"","categories":"","description":"Demos and Presentations featured by our community contributors and users\n","excerpt":"Demos and Presentations featured by our community contributors and ‚Ä¶","ref":"/secrets-store-csi-driver-provider-azure/demos/community-demos-and-presentations/","tags":"","title":"Community Demos and Presentations"},{"body":"For more information on securing an Ingress with TLS, refer to this guide\nImporting the ingress TLS certificate to the cluster can be included in the following deployments:\n Application - Application deployment manifest declares and mounts the csi provider volume. Only when the application is deployed the certificate is made available in the cluster and when it is removed the secret is gone. This scenario fits development teams who are responsible for the application‚Äôs security infrastructure and their integration with the cluster. Ingress Controller - Ingress deployment is modified to declare and mount the csi provider volume. The secret is imported when Ingress pods are created and the application‚Äôs pods have no access to the TLS certificate. This scenario fits scenarios where one team (i.e. IT) manages and provisions infrastructure and networking components (including HTTPS TLS certificates) and other teams manage application lifecycle. note: in this case, ingress is specific to a single namespace/workload and is deployed in the same namespace as the application.  Generate a TLS Cert export CERT_NAME=ingresscert openssl req -x509 -nodes -days 365 -newkey rsa:2048 \\  -out ingress-tls.crt \\  -keyout ingress-tls.key \\  -subj \"/CN=demo.test.com/O=ingress-tls\" Import the TLS certificate to Azure Key Vault Convert the .crt certificate to pfx format and import it to Azure Key Vault. For example:\nexport AKV_NAME=\"[YOUR AKV NAME]\" openssl pkcs12 -export -in ingress-tls.crt -inkey ingress-tls.key -out $CERT_NAME.pfx # skip Password prompt az keyvault certificate import --vault-name $AKV_NAME -n $CERT_NAME -f $CERT_NAME.pfx Setup Cluster Prerequisites Deploy Secrets Store CSI Driver and the Azure Key Vault Provider Deploy the Azure Key Vault Provider and Secrets Store CSI Driver components:\nhelm repo add csi-secrets-store-provider-azure https://raw.githubusercontent.com/Azure/secrets-store-csi-driver-provider-azure/master/charts helm install csi csi-secrets-store-provider-azure/csi-secrets-store-provider-azure Refer to installation for more details and validation.\nOptional: Deploy AAD Pod Identity If using AAD pod identity to access Azure Keyvault, make sure it is configured properly in the cluster. Refer to doc on how to use AAD Pod identity to access keyvault.\nexport AAD_POD_IDENTITY_NAME=azure-kv Deploy a SecretsProviderClass Resource Create a namespace export NAMESPACE=ingress-test kubectl create ns $NAMESPACE Create the SecretProviderClass  To provide identity to access key vault, refer to the following section. Set the tenantId and keyvaultName If using AAD pod identity to access Azure Key Vault - set usePodIdentity: \"true\" Use objectType: secret for the certificate, as this is the only way to retrieve the certificate and private key from azure key vault as documented here Set secret type to kubernetes.io/tls  export TENANT_ID=[YOUR TENANT ID] cat \u003c\u003cEOF | kubectl apply -n $NAMESPACE -f -apiVersion:secrets-store.csi.x-k8s.io/v1alpha1kind:SecretProviderClassmetadata:name:azure-tlsspec:provider:azuresecretObjects:# secretObjects defines the desired state of synced K8s secret objects- secretName:ingress-tls-csitype:kubernetes.io/tlsdata:- objectName:$CERT_NAMEkey:tls.key- objectName:$CERT_NAMEkey:tls.crtparameters:usePodIdentity:\"false\"keyvaultName:$AKV_NAME # the name of the KeyVaultobjects:| array: - | objectName: $CERT_NAME objectType: secret tenantId: $TENANT_ID # the tenant ID of the KeyVaultEOFDeploy Ingress Controller Add the official ingress chart repository helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx helm repo update Deploy Ingress Depending on the TLS certificate lifecycle, follow one of the following steps:\n  Bind certificate to Application    Application‚Äôs deployment will reference the csi store provider.\n helm install ingress-nginx/ingress-nginx --generate-name \\  --namespace $NAMESPACE \\  --set controller.replicaCount=2 \\  --set controller.nodeSelector.\"beta\\.kubernetes\\.io/os\"=linux \\  --set defaultBackend.nodeSelector.\"beta\\.kubernetes\\.io/os\"=linux Next, Deploy the application.\n  Bind certificate to Ingress    NOTE: Ingress controller references a Secrets Store CSI volume and a secretProviderClass object created earlier. A Kubernetes secret ingress-tls-csi will be created by the CSI driver as a result of ingress controller creation.\n helm install ingress-nginx/ingress-nginx --generate-name \\  --namespace $NAMESPACE \\  --set controller.replicaCount=2 \\  --set controller.nodeSelector.\"beta\\.kubernetes\\.io/os\"=linux \\  --set defaultBackend.nodeSelector.\"beta\\.kubernetes\\.io/os\"=linux \\  --set controller.podLabels.aadpodidbinding=$AAD_POD_IDENTITY_NAME \\  -f - \u003c\u003cEOF controller: extraVolumes: - name: secrets-store-inline csi: driver: secrets-store.csi.k8s.io readOnly: true volumeAttributes: secretProviderClass: \"azure-tls\" nodePublishSecretRef: name: secrets-store-creds extraVolumeMounts: - name: secrets-store-inline mountPath: \"/mnt/secrets-store\" readOnly: true EOF If not using service principal mode, remove the following snippet from the script:\nnodePublishSecretRef: name: secrets-store-creds Check for the Kubernetes Secret created by the CSI driver (ingress-bound certificate) kubectl get secret -n $NAMESPACE NAME TYPE DATA AGE ingress-tls-csi kubernetes.io/tls 2 1m34s Next, Deploy the application.\nDeploy Test Apps Depending on the TLS certificate lifecycle, follow one of the following steps:\n  Deploy Application with Reference to Secrets Store CSI    NOTE: These apps reference a Secrets Store CSI volume and a secretProviderClass object created earlier. A Kubernetes secret ingress-tls-csi will be created by the CSI driver as a result of the app creation in the same namespace.\n volumes:- name:secrets-store-inlinecsi:driver:secrets-store.csi.k8s.ioreadOnly:truevolumeAttributes:secretProviderClass:\"azure-tls\"nodePublishSecretRef:name:secrets-store-credsIf not using service principal mode, remove the following snippet from deployment-app-one.yaml and deployment-app-two.yaml\nnodePublishSecretRef:name:secrets-store-credsDeploy the test apps (application-bound certificate) kubectl apply -f https://raw.githubusercontent.com/Azure/secrets-store-csi-driver-provider-azure/master/docs/sample/ingress-controller-tls/deployment-app-one.yaml -n $NAMESPACE kubectl apply -f https://raw.githubusercontent.com/Azure/secrets-store-csi-driver-provider-azure/master/docs/sample/ingress-controller-tls/deployment-app-two.yaml -n $NAMESPACE Check for the Kubernetes Secret created by the CSI driver (application-bound certificate) kubectl get secret -n $NAMESPACE NAME TYPE DATA AGE ingress-tls-csi kubernetes.io/tls 2 1m34s Next, Deploy the ingress resource\n  Deploy Application with Ingress reference to Secrets Store CSI   remove the following snippet from deployment-app-one.yaml and deployment-app-two.yaml\nvolumeMounts:- name:secrets-store-inlinemountPath:\"/mnt/secrets-store\"readOnly:truevolumes:- name:secrets-store-inlinecsi:driver:secrets-store.csi.k8s.ioreadOnly:truevolumeAttributes:secretProviderClass:\"azure-tls\"nodePublishSecretRef:name:secrets-store-credsDeploy the test apps (ingress-bound certificate) kubectl apply -f https://raw.githubusercontent.com/Azure/secrets-store-csi-driver-provider-azure/master/docs/sample/ingress-controller-tls/deployment-app-one.yaml -n $NAMESPACE kubectl apply -f https://raw.githubusercontent.com/Azure/secrets-store-csi-driver-provider-azure/master/docs/sample/ingress-controller-tls/deployment-app-two.yaml -n $NAMESPACE Next, Deploy the ingress resource\nDeploy an Ingress Resource referencing the Secret created by the CSI driver  NOTE: The ingress resource references the Kubernetes secret ingress-tls-csi created by the CSI driver as a result of the app creation.\nThe following snippet shows the code which makes this happen:\n tls:- hosts:- demo.test.comsecretName:ingress-tls-csikubectl apply -f https://raw.githubusercontent.com/Azure/secrets-store-csi-driver-provider-azure/master/docs/sample/ingress-controller-tls/ingress.yaml -n $NAMESPACE Get the External IP of the Ingress Controller kubectl get service -l app=nginx-ingress --namespace $NAMESPACE NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE nginx-ingress-1588032400-controller LoadBalancer 10.0.255.157 52.xx.xx.xx 80:31293/TCP,443:31265/TCP 19m nginx-ingress-1588032400-default-backend ClusterIP 10.0.223.214 \u003cnone\u003e 80/TCP 19m Test Ingress with TLS Using curl to verify ingress configuration using TLS. Replace the public IP with the external IP of the ingress controller service from the previous step.\ncurl -v -k --resolve demo.test.com:443:52.xx.xx.xx https://demo.test.com # You should see the following in your output * subject: CN=demo.test.com; O=ingress-tls * start date: Apr 15 04:23:46 2020 GMT * expire date: Apr 15 04:23:46 2021 GMT * issuer: CN=demo.test.com; O=ingress-tls * SSL certificate verify result: self signed certificate (18), continuing anyway. ","categories":"","description":"This guide demonstrates steps required to setup Secrets Store CSI driver and Azure Key Vault Provider to enable applications to work with NGINX Ingress Controller with TLS certificates stored in Key Vault\n","excerpt":"This guide demonstrates steps required to setup Secrets Store CSI ‚Ä¶","ref":"/secrets-store-csi-driver-provider-azure/configurations/ingress-tls/","tags":"","title":"Enable NGINX Ingress Controller with TLS"},{"body":" Supported with Linux and Windows\n \rExamples\r SecretProviderClass  # This is a SecretProviderClass example using user-assigned identity to access Key VaultapiVersion:secrets-store.csi.x-k8s.io/v1alpha1kind:SecretProviderClassmetadata:name:azure-kvname-user-msispec:provider:azureparameters:usePodIdentity:\"false\"useVMManagedIdentity:\"true\"userAssignedIdentityID:\"\u003cclient id of user assigned identity\u003e\"keyvaultName:\"kvname\"cloudName:\"\"# [OPTIONAL for Azure] if not provided, azure environment will default to AzurePublicCloudobjects:| array: - | objectName: secret1 objectType: secret # object types: secret, key or cert objectVersion: \"\" # [OPTIONAL] object versions, default to latest if empty - | objectName: key1 objectType: key objectVersion: \"\" tenantId: \"tid\" # the tenant ID of the KeyVault  Pod yaml  # This is a sample pod definition for using SecretProviderClass and user-assigned identity to access Key Vaultkind:PodapiVersion:v1metadata:name:busybox-secrets-store-inline-user-msispec:containers:- name:busyboximage:k8s.gcr.io/e2e-test-images/busybox:1.29command:- \"/bin/sleep\"- \"10000\"volumeMounts:- name:secrets-store01-inlinemountPath:\"/mnt/secrets-store\"readOnly:truevolumes:- name:secrets-store01-inlinecsi:driver:secrets-store.csi.k8s.ioreadOnly:truevolumeAttributes:secretProviderClass:\"azure-kvname-user-msi\"\rConfigure User-assigned Managed Identity to access Keyvault In AKS you can use the User-assigned Kubelet managed identity (doesn‚Äôt support BYO today) or create your own user-assigned managed identity as described below.\n You can create an AKS cluster with managed identities now and then skip steps 1 and 2. To get the clientID of the managed identity, run the following command:\naz aks show -g \u003cresource group\u003e -n \u003caks cluster name\u003e --query identityProfile.kubeletidentity.clientId -o tsv    Create Azure User-assigned Managed Identity\naz identity create -g \u003cRESOURCE GROUP\u003e -n \u003cIDENTITY NAME\u003e   Assign Azure User-assigned Managed Identity to VM/VMSS\nFor VMSS:\naz vmss identity assign -g \u003cRESOURCE GROUP\u003e -n \u003cK8S-AGENT-POOL-VMSS\u003e --identities \u003cUSER ASSIGNED IDENTITY RESOURCE ID\u003e If the cluster is using AvailabilitySet, then assign the identity to each of the VM instances:\naz vm identity assign -g \u003cRESOURCE GROUP\u003e -n \u003cK8S-AGENT-POOL-VM\u003e --identities \u003cUSER ASSIGNED IDENTITY RESOURCE ID\u003e   Grant User-assigned Managed Identity permission to access Keyvault\nEnsure that your User-assigned Managed Identity has the role assignments required to access content in keyvault instance. Run the following Azure CLI commands to assign the roles if required:\n# set policy to access keys in your Keyvault az keyvault set-policy -n $KEYVAULT_NAME --key-permissions get --spn \u003cUSER-ASSIGNED MANAGED IDENTITY CLIENTID\u003e # set policy to access secrets in your Keyvault az keyvault set-policy -n $KEYVAULT_NAME --secret-permissions get --spn \u003cUSER-ASSIGNED MANAGED IDENTITY CLIENTID\u003e # set policy to access certs in your Keyvault az keyvault set-policy -n $KEYVAULT_NAME --certificate-permissions get --spn \u003cUSER-ASSIGNED MANAGED IDENTITY CLIENTID\u003e   Deploy your application. Specify useVMManagedIdentity to true and provide userAssignedIdentityID.\nuseVMManagedIdentity:\"true\"userAssignedIdentityID:\"\u003cclient id of the managed identity\u003e\"  ","categories":"","description":"Use a User-assigned Managed Identity to access Keyvault.\n","excerpt":"Use a User-assigned Managed Identity to access Keyvault.\n","ref":"/secrets-store-csi-driver-provider-azure/configurations/identity-access-modes/user-assigned-msi-mode/","tags":"","title":"User-assigned Managed Identity"},{"body":"","categories":"","description":"An overview of all the configuration features of Azure KeyVault Provider for Secrets Store CSI Driver\n","excerpt":"An overview of all the configuration features of Azure KeyVault ‚Ä¶","ref":"/secrets-store-csi-driver-provider-azure/configurations/","tags":"","title":"Configurations"},{"body":" Supported with Linux and Windows\n \rExamples\r SecretProviderClass  # This is a SecretProviderClass example using system-assigned identity to access Key VaultapiVersion:secrets-store.csi.x-k8s.io/v1alpha1kind:SecretProviderClassmetadata:name:azure-kvname-system-msispec:provider:azureparameters:usePodIdentity:\"false\"useVMManagedIdentity:\"true\"userAssignedIdentityID:\"\"# If empty, then defaults to use the system assigned identity on the VMkeyvaultName:\"kvname\"cloudName:\"\"# [OPTIONAL for Azure] if not provided, azure environment will default to AzurePublicCloudobjects:| array: - | objectName: secret1 objectType: secret # object types: secret, key or cert objectVersion: \"\" # [OPTIONAL] object versions, default to latest if empty - | objectName: key1 objectType: key objectVersion: \"\" tenantId: \"tid\" # the tenant ID of the KeyVault  Pod yaml  # This is a sample pod definition for using SecretProviderClass and system-assigned identity to access Key Vaultkind:PodapiVersion:v1metadata:name:busybox-secrets-store-inline-system-msispec:containers:- name:busyboximage:k8s.gcr.io/e2e-test-images/busybox:1.29command:- \"/bin/sleep\"- \"10000\"volumeMounts:- name:secrets-store01-inlinemountPath:\"/mnt/secrets-store\"readOnly:truevolumes:- name:secrets-store01-inlinecsi:driver:secrets-store.csi.k8s.ioreadOnly:truevolumeAttributes:secretProviderClass:\"azure-kvname-system-msi\"\rConfigure System-assigned Managed Identity to access Keyvault Before this step, you need to enable system-assigned managed identity in your cluster VM/VMSS.\n  Verify that the nodes have their own system-assigned managed identity\nFor VMSS:\naz vmss identity show -g \u003cresource group\u003e -n \u003cvmss scalset name\u003e -o yaml If the cluster is using AvailabilitySet, then check the system-assigned identity exists on all the VM instances:\naz vm identity show -g \u003cresource group\u003e -n \u003cvm name\u003e -o yaml The output should contain type: SystemAssigned. Make a note of the principalId.\n  Grant System-assigned Managed Identity permission to access Keyvault\nEnsure that your System-assigned Managed Identity has the role assignments required to access content in keyvault instance. Run the following Azure CLI commands to assign the roles if required:\n# set policy to access keys in your Keyvault az keyvault set-policy -n $KEYVAULT_NAME --key-permissions get --object-id \u003cSYSTEM-ASSIGNED MANAGED IDENTITY PRINCIPALID\u003e # set policy to access secrets in your Keyvault az keyvault set-policy -n $KEYVAULT_NAME --secret-permissions get --object-id \u003cSYSTEM-ASSIGNED MANAGED IDENTITY PRINCIPALID\u003e # set policy to access certs in your Keyvault az keyvault set-policy -n $KEYVAULT_NAME --certificate-permissions get --object-id \u003cSYSTEM-ASSIGNED MANAGED IDENTITY PRINCIPALID\u003e   Deploy your application. Specify useVMManagedIdentity to true.\nuseVMManagedIdentity:\"true\"  ","categories":"","description":"Use a System-assigned Managed Identity to access Keyvault.\n","excerpt":"Use a System-assigned Managed Identity to access Keyvault.\n","ref":"/secrets-store-csi-driver-provider-azure/configurations/identity-access-modes/system-assigned-msi-mode/","tags":"","title":"System-assigned Managed Identity"},{"body":"Logging Below is a list of commands you can use to view relevant logs of Azure Key Vault provider and Secrets Store CSI Driver.\nIsolate errors from logs You can use grep ^E and --since flag from kubectl to isolate any errors occurred after a given duration.\nFor Azure Key Vault provider versions less than 0.0.9\nTo troubleshoot issues with the csi driver and the provider, you can look at logs from the secrets-store container of the csi driver pod running on the same node as your application pod:\n# find the secrets store csi driver pod running on the same node as your application pod kubectl get pods -l app=secrets-store-csi-driver -o wide kubectl logs \u003cdriver pod name\u003e secrets-store --since=1h | grep ^E For Azure Key Vault provider versions equal to and greater than 0.0.9\nFor 0.0.9+ the provider logs are available in the provider pods. To troubleshoot issues with the provider, you can look at logs from the provider pod running on the same node as your application pod\n# find the csi-secrets-store-provider-azure pod running on the same node as your application pod kubectl get pods -l app=csi-secrets-store-provider-azure -o wide kubectl logs \u003cprovider pod name\u003e --since=1h | grep ^E For CSI driver logs\n# find the secrets store csi driver pod running on the same node as your application pod kubectl get pods -l app=secrets-store-csi-driver -o wide kubectl logs \u003cdriver pod name\u003e secrets-store --since=1h | grep ^E  It is always a good idea to include relevant logs from Azure Key Vault provider and Secrets Store CSI Driver when opening a new issue.\n Common Issues Common issues or questions that users have run into when using Azure Key Vault provider for Secrets Store CSI Driver are detailed below.\ndriver name secrets-store.csi.k8s.io not found in the list of registered CSI drivers If you received the following error message in the pod events:\nWarning FailedMount 42s (x12 over 8m56s) kubelet, akswin000000 MountVolume.SetUp failed for volume \"secrets-store01-inline\" : kubernetes.io/csi: mounter.SetUpAt failed to get CSI client: driver name secrets-store.csi.k8s.io not found in the list of registered CSI drivers It means the Secrets Store CSI Driver pods aren‚Äôt running on the node where application is running.\n If you‚Äôve installed the AKV provider using deployment manifests, then make sure to follow the instructions to install the Secrets Store CSI Driver. If you‚Äôve already deployed the Secrets Store CSI Driver, then check if the node is tainted. If node is tainted, then redeploy the Secrets Store CSI Driver and Azure Key Vault provider by adding toleration for the taints. If your application is running on windows node, then make sure to install the Secrets Store CSI Driver and Azure Key Vault provider on windows nodes by using the helm configuration values.  Past issues:\n https://github.com/Azure/secrets-store-csi-driver-provider-azure/issues/213 https://github.com/Azure/secrets-store-csi-driver-provider-azure/issues/346  failed to get key vault token: nmi response failed with status code: 404 If you received the following error message in the logs/events:\nWarning FailedMount 74s kubelet MountVolume.SetUp failed for volume \"secrets-store-inline\" : kubernetes.io/csi: mounter.SetupAt failed: rpc error: code = Unknown desc = failed to mount secrets store objects for pod default/test, err: rpc error: code = Unknown desc = failed to mount objects, error: failed to get keyvault client: failed to get key vault token: nmi response failed with status code: 404, err: \u003cnil\u003e It means the NMI component in aad-pod-identity returned an error for token request. To get more details on the error, check the MIC pod logs and refer to the AAD Pod Identity troubleshooting guide to resolve the issue.\nPast issues:\n https://github.com/Azure/secrets-store-csi-driver-provider-azure/issues/119 https://github.com/Azure/secrets-store-csi-driver-provider-azure/issues/200 https://github.com/Azure/secrets-store-csi-driver-provider-azure/issues/352  failed to find provider binary azure, err: stat /etc/kubernetes/secrets-store-csi-providers/azure/provider-azure: no such file or directory If you received the following error message in the logs/events:\nWarning FailedMount 85s (x10 over 5m35s) kubelet, aks-default-28951543-vmss000000 MountVolume.SetUp failed for volume \"secrets-store01-inline\" : kubernetes.io/csi: mounter.SetupAt failed: rpc error: code = Unknown desc = failed to mount secrets store objects for pod default/nginx-secrets-store-inline-user-msi, err: failed to find provider binary azure, err: stat /etc/kubernetes/secrets-store-csi-providers/azure/provider-azure: no such file or directory It means the driver is unable to communicate with the provider.\n If you‚Äôre installing provider version \u003c 0.0.9, check if the provider pods are running on all nodes. If you‚Äôre installing provider version \u003e= 0.0.9, follow the Installation steps to configure the driver to use grpc for communication with the provider.  Past issues:\n https://github.com/Azure/secrets-store-csi-driver-provider-azure/issues/254 https://github.com/Azure/secrets-store-csi-driver-provider-azure/issues/259 https://github.com/Azure/secrets-store-csi-driver-provider-azure/issues/269 https://github.com/Azure/secrets-store-csi-driver-provider-azure/issues/303  ","categories":"","description":"An overview of a list of components to assist in troubleshooting.\n","excerpt":"An overview of a list of components to assist in troubleshooting.\n","ref":"/secrets-store-csi-driver-provider-azure/troubleshooting/","tags":"","title":"Troubleshooting"},{"body":"Upgrading to Key Vault provider 0.0.9+ Warning tl;dr - 0.0.9+ release of the Azure Key Vault provider is incompatible with the Secrets Store CSI Driver versions \u003c v0.0.14.  Prior to v0.0.14 release of the Secrets Store CSI Driver, the driver communicated with the provider by invoking the provider binary installed on the host. However with v0.0.14 the driver now introduces a new option to communicate with the provider using gRPC. This feature is enabled by a feature flag in the driver --grpc-supported-providers=azure. The 0.0.9 release of the Azure Key Vault provider implements the gRPC server changes and is no longer backward compatible with the Secrets Store CSI Driver versions \u003c v0.0.14.\nPlease carefully read this doc as you upgrade to the latest release of the Azure Key Vault Provider\nIf the Secrets Store CSI Driver and Azure Key Vault Provider were installed using helm charts from this repo helm upgrade to the latest chart release in the repo will update the Azure Key Vault Provider and Secrets Store CSI Driver to the compatible versions\n This updates the driver version to v0.0.14+ This updates the provider version to 0.0.9+ This updates the driver manifest to include the flag --grpc-supported-providers=azure to enable communication between driver and provider using gRPC  Run the following commands to confirm the images have been updated -\n secrets-store container in secrets-store-csi-driver pod is running v0.0.14+  ‚ûú kubectl get ds -l app=secrets-store-csi-driver -o jsonpath='{range .items[*]}{.spec.template.spec.containers[1].image}{\"\\n\"}' mcr.microsoft.com/k8s/csi/secrets-store/driver:v0.0.14 secrets-store container in the secrets-store-csi-driver pod contains the arg --grpc-supported-providers=azure  ‚ûú kubectl get ds -l app=secrets-store-csi-driver -o jsonpath='{range .items[*]}{.spec.template.spec.containers[1].args}{\"\\n\"}' [\"--debug=true\",\"--endpoint=$(CSI_ENDPOINT)\",\"--nodeid=$(KUBE_NODE_NAME)\",\"--provider-volume=/etc/kubernetes/secrets-store-csi-providers\",\"--grpc-supported-providers=azure\",\"--metrics-addr=:8080\"] csi-secrets-store-provider-azure pod is running 0.0.9+  ‚ûú kubectl get ds -l app=csi-secrets-store-provider-azure -o jsonpath='{range .items[*]}{.spec.template.spec.containers[0].image}{\"\\n\"}' mcr.microsoft.com/oss/azure/secrets-store/provider-azure:0.0.9 If the Secrets Store CSI Driver and Azure Key Vault Provider were installed using deployment yamls The driver and provider need to be updated one after the other to ensure compatible versions are being run.\n Update the driver by installing the yamls from Install the Secrets Store CSI Driver  ACTION REQUIRED If using the yamls from the Secrets Store CSI Driver, add the following flag --grpc-supported-providers=azure to the Linux and Windows daemonset manifests.  The flag needs to be added to the secrets-store container args   ACTION REQUIRED If using the helm charts from secrets-store-csi-driver, then run helm upgrade with --set grpcSupportedProviders=azure   After the driver is upgraded to the latest version install the latest Azure Key Vault provider by following the doc  ","categories":"","description":"This document highlights the required actions for upgrading to the latest release\n","excerpt":"This document highlights the required actions for upgrading to the ‚Ä¶","ref":"/secrets-store-csi-driver-provider-azure/upgrading/","tags":"","title":"Upgrading"},{"body":"In order to pull secret content from Keyvault instances hosted on air-gapped and/or on-prem Azure clouds, your SecretProviderClass resource must include the following:\nparameters:cloudName:\"AzureStackCloud\"cloudEnvFileName:\"/path/to/custom/environment.json\"Parameter cloudEnvFileName should be the path to a JSON file that contains the custom cloud environment details that azure-sdk-for-go needs to interact with the target Keyvault instance. Typically, the custom cloud environment file is stored in the file system of the Kubernetes node and accessible to the Azure Key Vault provider pods through a mounted volume.\nEven if the target cloud is not an Azure Stack Hub cloud, cloud name must be set to \"AzureStackCloud\" to signal azure-sdk-for-go to load the custom cloud environment details from cloudEnvFileName.\nEnvironment files The custom cloud environment sample below shows the minimum set of properties required:\n{ \"name\": \"AzureStackCloud\", \"activeDirectoryEndpoint\": \"https://login.microsoftonline.com/\", \"keyVaultEndpoint\": \"https://vault.azure.net/\", \"keyVaultDNSSuffix\": \"vault.azure.net\" } ","categories":"","description":"Pull secret content from KeyVault instances hosted on air-gapped and/or on-prem Azure clouds\n","excerpt":"Pull secret content from KeyVault instances hosted on air-gapped ‚Ä¶","ref":"/secrets-store-csi-driver-provider-azure/configurations/custom-environments/","tags":"","title":"Custom Azure Environments"},{"body":"Azure Key Vault Provider for Secrets Store CSI Driver is an open source project that is not covered by the Microsoft Azure support policy. Please search open issues here, and if your issue isn‚Äôt already represented please open a new one. The project maintainers will respond to the best of their abilities.\n","categories":"","description":"Azure Key Vault Provider for Secrets Store CSI Driver is an open source project that is not covered by the Microsoft Azure support policy\n","excerpt":"Azure Key Vault Provider for Secrets Store CSI Driver is an open ‚Ä¶","ref":"/secrets-store-csi-driver-provider-azure/support/","tags":"","title":"Support"},{"body":" Note: This behavior was introduced in 0.0.6 release of Azure Key Vault Provider for Secrets Store CSI Driver. This is backward incompatible with the prior releases.\n The Azure Key Vault Provider for Secrets Store CSI Driver has been designed to closely align with the current behavior of az keyvault certificate/secret/key download.\nAzure Key Vault design makes sharp distinctions between Keys, Secrets and Certificates. The KeyVault service‚Äôs Certificates features were designed making use of it‚Äôs Keys and Secrets capabilities.\n When a Key Vault certificate is created, an addressable key and secret are also created with the same name. The Key Vault key allows key operations and the Key Vault secret allows retrieval of the certificate value as a secret. A Key Vault certificate also contains public x509 certificate metadata.\n The KeyVault service stores both the public and the private parts of your certificate in a KeyVault secret, along with any other secret you might have created in that same KeyVault instance.\nHow to obtain the certificate Knowing that the certificate is stored in a Key Vault certificate, we can retrieve it by using object type cert.\n Note: For chain of certificates, using object type cert only returns the Server certificate and not the entire chain.\n array:- | objectName: certName objectType: cert objectVersion: \"\" The contents of the file will be the certificate in PEM format.\nHow to obtain the public key Knowing that the public key is stored in a Key Vault key, we can retrieve it by using object type key\narray:- | objectName: certName objectType: key objectVersion: \"\" The contents of the file will be the public key in PEM format.\nHow to obtain the private key and certificate Knowing that the private key is stored in a Key Vault secret with the public certificate included, we can retrieve it by using object type secret\narray:- | objectName: certName objectType: secret objectVersion: \"\" The contents of the file will be the private key and certificate in PEM format.\n Note: For chain of certificates, using object type secret returns entire certificate chain along with the private key.\n ","categories":"","description":"How to fetch the Certificates and Keys using Azure Key Vault Provider for Secrets Store CSI Driver\n","excerpt":"How to fetch the Certificates and Keys using Azure Key Vault Provider ‚Ä¶","ref":"/secrets-store-csi-driver-provider-azure/configurations/getting-certs-and-keys/","tags":"","title":"Getting Certificates and Keys using Azure Key Vault Provider"},{"body":"Contributing This project welcomes contributions and suggestions. Most contributions require you to agree to a Contributor License Agreement (CLA) declaring that you have the right to, and actually do, grant us the rights to use your contribution. For details, visit https://cla.opensource.microsoft.com.\nWhen you submit a pull request, a CLA bot will automatically determine whether you need to provide a CLA and decorate the PR appropriately (e.g., status check, comment). Simply follow the instructions provided by the bot. You will only need to do this once across all repos using our CLA.\nThis project has adopted the Microsoft Open Source Code of Conduct. For more information see the Code of Conduct FAQ or contact opencode@microsoft.com with any additional questions or comments.\n","categories":"","description":"How to contribute to the project\n","excerpt":"How to contribute to the project\n","ref":"/secrets-store-csi-driver-provider-azure/contribution-guidelines/","tags":"","title":"Contribution Guidelines"},{"body":"Azure Key Vault provider for Secrets Store CSI driver allows you to get secret contents stored in an Azure Key Vault instance and use the Secrets Store CSI driver interface to mount them into Kubernetes pods.\nFeatures  Mounts secrets/keys/certs on pod start using a CSI volume Supports mounting multiple secrets store objects as a single volume Supports pod identity to restrict access with specific identities Supports pod portability with the SecretProviderClass CRD Supports windows containers (Kubernetes version v1.18+) Supports sync with Kubernetes Secrets (Secrets Store CSI Driver v0.0.10+) Supports auto rotation of secrets (Secrets Store CSI Driver v0.0.16+)  ","categories":"","description":"","excerpt":"Azure Key Vault provider for Secrets Store CSI driver allows you to ‚Ä¶","ref":"/secrets-store-csi-driver-provider-azure/","tags":"","title":"Azure Key Vault Provider for Secrets Store CSI Driver"}]